"""
Implementation of the differential equations for solving the CME.


    This code generates the differential equations
    and interfaces to Scipy's VODE initial value problem solver.
  
    The routines are
    
    * diff_eqs_factory  -- takes the domain shape & propensities as input
		returns a diff_eqs routine.
		
		Required keyword arguments:
		
		- np : a tuple or list giving the shape of the state space
		
		- propensities : a tuple or list of the propensity functions
		
		Optional keyword arguments:
		
		- norigin : the origin of the state space. By default,
		  this is (0,)*len(np), i.e., the zero state.

		The diff_eqs_factory function defines the following inner routines.
		These are described below:

                   
    	+ diff_eqs  -- takes the time t and probability p and returns the
			rhs A*p of the master equations, where b(t) is a term
			supplied by the approximate boundary conditions, if any are
			specified. This routine is generated by the diff_eqs_factory
			routine.
                   
    * cme	-- our interface to the cme solver. This routine returns a
		scipy.integrate.ode instance to solve the cme for the specified
		problem.
    
    These routines are all based on a truncated subspace of the state space
    which is defined by np (size of this cell) and norigin (coordinates of 
    origin)
    Markus Hegland, ANU, June 2009
    
"""


def gen_dest_indices(offset_vector):
    """
    maps offset_vector to corresponding slice tuple for destination indices
    """
    indices = []
    for i in offset_vector:
        if i == 0:
            indices.append(slice(None))
        elif i > 0:
            indices.append(slice(i, None))
        else:
            indices.append(slice(None, i))
    return tuple(indices)

def gen_source_indices(offset_vector):
    """
    maps offset_vector to corresponding slice tuple for source indices
    """
    return gen_dest_indices([-i for i in offset_vector])

def process_offset_vectors(np, propensities, offset_vectors):
    """
    generates offset_vectors if none are supplied, otherwise verifies
    offset_vectors is compatible with np and propensities.
    """
    
    if offset_vectors is None:
        if len(np) != len(propensities):
            complaint = (('Length of np (%d) must equal '%len(np))+
                ('length of propensities (%d) if '%len(propensities))+
                'offset_vectors argument is not explicitly supplied.')
            raise ValueError(complaint)
        
        # default behaviour : implicitly assume reaction count state space,
        # generate offsets accordingly
        offset_zero = (0, )
        offset_one = (1, )
        offset_vectors = []
        dims = len(np)
        for dim in xrange(len(propensities)):
            offset = dim*offset_zero + offset_one + (dims-2)*offset_zero
            offset_vectors.append(offset)
    else:
        if len(offset_vectors) != len(propensities):
            complaint = (('Lengths of propensities (%d) '%len(propensities))+
                ('and offset_vectors (%d) must agree.'%len(offset_vectors)))
            raise ValueError(complaint)
        for i, offset_vector in enumerate(offset_vectors):
            if len(offset_vector) != len(np):
                complaint = (('Length of offset_vectors[%d] '%i)+
                             'does not agree with length of np.')
                raise ValueError(complaint)
    return offset_vectors

def gen_reaction_actions(np, propensities, offset_vectors, norigin):
    """
    generates an array of tuples of the form
    (coefficients, source_indices, dest_indices).
    These can be used to compute the map
    p -> dp/dt in the Chemical Master Equation.
    """
    
    import cmepy.util
    import itertools
    
    reaction_actions = []
    
    for (propensity, offset_vector) in itertools.izip(propensities,
                                                      offset_vectors):
        source_indices = gen_source_indices(offset_vector)
        dest_indices = gen_dest_indices(offset_vector)
        full_source_indices = cmepy.util.indices_ext(np,
                                                     source_indices,
                                                     norigin)
        coefficients = propensity(*full_source_indices)
        reaction_actions.append((coefficients, source_indices, dest_indices))
    
    return reaction_actions

def process_time_dependence(time_dependence, propensities):
    """
    Verifies time dependence functions, if any, are compatible with
    propensity functions.
    """
    if time_dependence is None:
        return None
    if len(time_dependence) != len(propensities):
        complaint = (('Length of time_dependence (%d)'%len(time_dependence))+
                      ' does not match length of '+
                      ('propensities (%d).'%len(propensities)))
        raise ValueError(complaint)
    return time_dependence

def diff_eqs_factory(**args):
    """
    creates and returns a function of the form diff_eqs(t,p) --> dp/dt(t,p)
    
    the supplied arguments are assumed to be invariant over all diff_eqs calls.
    """
    
    import numpy 
    
    np = args['np']
    num_states = numpy.prod(np)
    propensities = args['propensities']
    norigin = args.get('norigin', None)
    offset_vectors = args.get('offset_vectors', None)
    offset_vectors = process_offset_vectors(np,
                                            propensities,
                                            offset_vectors) 
    reaction_actions = gen_reaction_actions(np,
                                            propensities,
                                            offset_vectors,
                                            norigin)
    time_dependence = args.get('time_dependence', None)
    time_dependence = process_time_dependence(time_dependence,
                                              propensities)
    
    def diff_eqs(t, p):
        """
        this routine defines our mapping diff_eqs(t,p) ---> dp/dt(t,p)
        which is later called by the ode solver
        """
        
        # the net flux will be accumulated inside the array p_dot
        p_dot = numpy.zeros(np)
        p_fat = numpy.reshape(p, np)
        
        for i, action in enumerate(reaction_actions):
            coefficients, source_indices, dest_indices = action
            # compute flux for this reaction
            flux = coefficients*p_fat[source_indices]
            # add time dependence, if any has been specified
            if time_dependence is not None:
                flux *= time_dependence[i](t)
            # flux flows from source to destination
            p_dot[source_indices] -= flux
            p_dot[dest_indices] += flux
        
        # return a flattened version of the flux
        return numpy.reshape(p_dot, (num_states,))
    
    return diff_eqs

def cme(np, propensities, **args):
    """
    Creates a scipy.integrate.ode instance for the specified cme problem
    
	The underlying ode solver employed is vode, in mode bdf.	
	"""
    import numpy
    from scipy.integrate import ode
    
    num_states = numpy.prod(np)
    p_0 = args.get('p0', None)
    t_0 = args.get('t0', 0.0)
    
    if p_0 is None:
        p_0 = numpy.zeros(num_states)
        p_0[0] = 1.0
    else:
        p_0 = numpy.reshape(p_0, (num_states,))
    
    factory_args = {}
    factory_args.update(args)
    factory_args['np'] = np
    factory_args['propensities'] = propensities
    
    # create the differential equations function
    diff_eq = diff_eqs_factory(**factory_args)
    # create the ode and set the integrator type and method
    cme_de = ode(diff_eq).set_integrator('vode', method='bdf')
    # set the initial values
    cme_de.set_initial_value(p_0, t_0)
    
    return cme_de

