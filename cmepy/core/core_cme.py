"""
Implementation of the differential equations for solving the CME.


    This second version of our code generates the differential equations
    and interfaces to a Scipy ODE initial value problem solver.
  
    The 4 routines are
    
    * diff_eqs_factory  -- takes the domain shape & propensities as input
		returns a diff_eqs routine.
		
		Required keyword arguments:
		
		- np : a tuple or list giving the shape of the state space
		
		- propensities : a tuple or list of the propensity functions
		
		Optional keyword arguments:
		
		- norigin : the origin of the reaction count state space. By default,
		  this is (0,)*len(np), i.e., the zero state.
		
		- boundary_flux_data : additional data to pass to the boundary flux
		  approximation function. By default no boundary conditions are applied.
		
		- solve_boundary_states : False or True (default). If False, probability
		  only flows into states along the output boundaries of the state space
		  from non-output boundary states. This allows the output boundary
		  states to be used to measure the 'truncation error' arising as
		  probability flows out of the state space. Alternatively, if set to
		  True, probability flows are computed over the whole state space. This
		  latter behaviour may be useful if probability is not intended to flow
		  out of the specified state space.
		
		- boundary_flux_estimator_factory : either None, indicating no custom
		  boundary flux estimator function, or a function of the form
		  
		    factory(np, boundary_flux_data) -> flux_estimator,
		  
		  where flux_estimator is a function of the form
		  
		    flux_estimator(t, p) -> iterator over (index, flux) pairs,
		  
		  which, for each t & p, supplies the boundary conditions. There are
		  added to pdot, the derivative of p, via:
		  
		  pdot = A*p(t)
		  for (index, flux) in flux_estimator(t):
		      pdot[index] += flux

		The diff_eqs_factory function defines two inner routines.
		These are described below:

		+ boundary_flux_estimator -- used by the diff_eqs
			routine to apply the boundary conditions, if any are
			specified. Boundary conditions are approximated as piecewise
			constant functions. This routine is generated by the
			diff_eqs_factory routine.
                   
    	+ diff_eqs  -- takes the time t and probability p and returns the
			rhs A*p + b(t) of the master equations, where b(t) is a term
			supplied by the approximate boundary conditions, if any are
			specified. This routine is generated by the diff_eqs_factory
			routine.
                   
    * cme	-- our interface to the cme solver. This routine returns a
		scipy.integrate.ode instance to solve the cme for the specified
		problem.
    
    These routines are all based on a truncated subspace of the state space
    which is defined by np (size of this cell) and norigin (coordinates of 
    origin)
    Markus Hegland, ANU, June 2009
    
"""


def diff_eqs_factory(**args):
    """
    creates and returns a function of the form diff_eqs(t,p) --> dp/dt(t,p)
    
    the supplied arguments are assumed to be invariant over all diff_eqs calls.
    """
    from numpy import zeros, prod, reshape
    from cmepy.util import indices_ext
    
    np = args['np']
    propensities = args['propensities']
    norigin = args.get('norigin', None)
    boundary_flux_data = args.get('boundary_flux_data', None)
    solve_boundary_states = args.get('solve_boundary_states', True)
    bdry_flux_est_factory = args.get('boundary_flux_estimator_factory', None)
    
    nd = len(np)
    lp = prod(np)
    
    ind_all = (slice(None),)
    ind_first = (slice(1),)
    ind_skip_last = (slice(None, -1),)
    ind_skip_first = (slice(1, None),)
    
    flux_source_ind = {}
    flux_dest_ind = {}
    A = {}
    
    if solve_boundary_states:
        # this mode permits flux between output boundary states.
        # this will lead to error in the case where the boundary state
        # is a truncation of a larger state-space.
        for i in xrange(nd):
            flux_source_ind[i] = (i*ind_all
                                + ind_skip_last
                                + (nd-i-1)*ind_all)
            flux_dest_ind[i] = (i*ind_all
                                + ind_skip_first
                                + (nd-i-1)*ind_all)
            ind_offset = indices_ext(np, flux_source_ind[i], norigin)
            A[i] = propensities[i](*ind_offset)
    else:
        # this mode prevents flux between output boundary states.
        # this means that probability only flows into a state along an
        # output boundary from an interior state.
        ind_interior = nd*ind_skip_last
        ind_offset = indices_ext(np, ind_interior, norigin)
        for i in xrange(nd):
            flux_source_ind[i] = nd*ind_skip_last
            flux_dest_ind[i] = (i*ind_skip_last
                                + ind_skip_first
                                + (nd-i-1)*ind_skip_last)
            A[i] = propensities[i](*ind_offset)
    
    if bdry_flux_est_factory is not None:
        # hook to employ custom boundary flux estimator functions.
        boundary_flux_estimator = bdry_flux_est_factory(np,
                                                        boundary_flux_data)
    else:
        def boundary_flux_estimator(t, p):
            """
            this routine approximates the boundary conditions
            using the supplied boundary flux data as a piecewise
		    constant function, and is called as part of the
		    diff_eqs routine defined below
            """
            (measured_time, measured_flux) = boundary_flux_data
            
            # only return flux if t is in within the interval of times
            # we have measurement data for
            if (t < measured_time[-1]) and (t > measured_time[0]):
                # find the closest measurement to t
                closest_measurement = measured_time.searchsorted(t)
                
                support = set(measured_flux[closest_measurement])
                # return flux components over the various boundaries
                for boundary_dim in support:
                    bdry_ind = (boundary_dim*ind_all
                                + ind_first
                                + (nd-boundary_dim-1)*ind_all)
                    
                    yield (bdry_ind,
                           measured_flux[closest_measurement][boundary_dim])
    
    def diff_eqs(t, p):
        """
        this routine defines our mapping diff_eqs(t,p) ---> dp/dt(t,p)
        which is later called by the ode solver
        """
        # flux will be accumulated inside the array pdot
        pdot = zeros(np)
        p_fat = reshape(p, (np))
        
        # add flux from propensities
        for dim in xrange(nd):
            flux = A[dim]*p_fat[flux_source_ind[dim]]
            pdot[flux_source_ind[dim]] -= flux
            pdot[flux_dest_ind[dim]] += flux
        
        # add flux from boundary conditions, if applicable
        if boundary_flux_data is not None:
            for (ind, flux) in boundary_flux_estimator(t, p_fat):
                pdot[ind] += flux
        
        # return a flattened version of the flux
        return reshape(pdot, (lp,))
    
    return diff_eqs

def cme(np, propensities, **args):
    """
    Creates a scipy.integrate.ode instance for the specified cme problem
    
	The underlying ode solver employed is vode, in mode bdf.	
	"""
    assert(len(np) == len(propensities))
    
    import numpy
    from scipy.integrate import ode
    
    num_states = numpy.prod(np)
    p_0 = args.get('p0', None)
    t_0 = args.get('t0', 0.0)
    
    if p_0 is None:
        p_0 = numpy.zeros(num_states)
        p_0[0] = 1.0
    else:
        p_0 = numpy.reshape(p_0, (num_states,))
    
    factory_args = {}
    factory_args.update(args)
    factory_args['np'] = np
    factory_args['propensities'] = propensities
    
    # create the differential equations function
    diff_eq = diff_eqs_factory(**factory_args)
    # create the ode and set the integrator type and method
    cme_de = ode(diff_eq).set_integrator('vode', method='bdf')
    # set the initial values
    cme_de.set_initial_value(p_0, t_0)
    
    return cme_de

